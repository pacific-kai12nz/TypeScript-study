# 3. 関数とその型

TypeScriptでは、関数の引数や戻り値に型を指定することができます。これにより、関数の入力と出力を明確に定義でき、誤った使い方を防ぐことができます。

## 関数の引数と戻り値の型指定

### 基本的な関数の型指定

関数の引数と戻り値に型を指定する基本的な方法を見てみましょう。

```typescript
// 引数と戻り値に型を指定する関数
function 足し算(a: number, b: number): number {
  return a + b;
}

// 使用例
const 結果 = 足し算(5, 3);  // 8
```

この例では：
- 引数 `a` と `b` は `number` 型
- 戻り値の型も `number` 型として指定されています
- コロン（`:`）の後に型を書くことで型を指定します

### 引数のない関数

引数がない関数でも、戻り値の型は指定できます。

```typescript
// 引数がなく、文字列を返す関数
function 挨拶(): string {
  return "こんにちは！";
}

// 使用例
const メッセージ = 挨拶();  // "こんにちは！"
```

### 戻り値のない関数

何も返さない関数（副作用のみを持つ関数）には、`void` 型を使います。

```typescript
// 戻り値のない関数
function ログ出力(メッセージ: string): void {
  console.log(メッセージ);
  // returnがない、または単にreturnと書くと自動的にvoid型になります
}

// 使用例
ログ出力("これはログメッセージです");  // コンソールに "これはログメッセージです" と出力
```

### 複数の型を返す関数

ユニオン型を使うと、関数が複数の型の値を返す可能性があることを示せます。

```typescript
// 文字列または数値を返す関数
function 文字列または数値(値: boolean): string | number {
  return 値 ? "真です" : 42;
}

// 使用例
const 結果1 = 文字列または数値(true);   // "真です" (string型)
const 結果2 = 文字列または数値(false);  // 42 (number型)
```

## オプションパラメータとデフォルトパラメータ

### オプションパラメータ

関数の引数の後に `?` を付けると、その引数はオプション（省略可能）となります。

```typescript
// オプションパラメータを持つ関数
function 挨拶(名前: string, 敬称?: string): string {
  if (敬称) {
    return `こんにちは、${名前}${敬称}！`;
  } else {
    return `こんにちは、${名前}さん！`;
  }
}

// 使用例
console.log(挨拶("田中"));          // "こんにちは、田中さん！"
console.log(挨拶("鈴木", "先生"));  // "こんにちは、鈴木先生！"
```

オプションパラメータは常に必須パラメータの後に配置する必要があります。

### デフォルトパラメータ

引数にデフォルト値を設定することもできます。デフォルト値を持つ引数は、値が渡されなかった場合にそのデフォルト値が使用されます。

```typescript
// デフォルトパラメータを持つ関数
function 挨拶2(名前: string, 敬称: string = "さん"): string {
  return `こんにちは、${名前}${敬称}！`;
}

// 使用例
console.log(挨拶2("田中"));          // "こんにちは、田中さん！"
console.log(挨拶2("鈴木", "先生"));  // "こんにちは、鈴木先生！"
```

デフォルトパラメータは型アノテーションの後に `= デフォルト値` の形で指定します。

## 関数シグネチャ

関数シグネチャとは、関数の「型」を定義するものです。関数の引数と戻り値の型を合わせて関数シグネチャと呼びます。

### 関数型の変数

関数型を変数に代入することができます。

```typescript
// 関数型の定義
type 計算関数 = (a: number, b: number) => number;

// 計算関数型の変数に関数を代入
const 足し算: 計算関数 = (a, b) => a + b;
const 引き算: 計算関数 = (a, b) => a - b;

// 使用例
console.log(足し算(5, 3));  // 8
console.log(引き算(5, 3));  // 2
```

この例では：
- `計算関数` という型を定義し、2つの数値を受け取り1つの数値を返す関数であることを示しています
- アロー関数（`=>`）を使って関数シグネチャを表現しています

### コールバック関数の型

関数を引数として受け取る高階関数でも、型を指定できます。

```typescript
// コールバック関数を受け取る関数
function 配列の各要素に処理(配列: number[], コールバック: (値: number) => number): number[] {
  const 結果: number[] = [];
  for (const 値 of 配列) {
    結果.push(コールバック(値));
  }
  return 結果;
}

// 使用例
const 元の配列 = [1, 2, 3, 4, 5];
const 2倍にする = (値: number): number => 値 * 2;
const 結果配列 = 配列の各要素に処理(元の配列, 2倍にする);
console.log(結果配列);  // [2, 4, 6, 8, 10]
```

### オーバーロード

TypeScriptでは、同じ関数名で異なる引数のパターンを定義する「関数オーバーロード」をサポートしています。

```typescript
// 関数オーバーロードの宣言
function 長さを取得(値: string): number;
function 長さを取得(値: any[]): number;
// 実装
function 長さを取得(値: string | any[]): number {
  return 値.length;
}

// 使用例
console.log(長さを取得("こんにちは"));  // 5
console.log(長さを取得([1, 2, 3]));     // 3
```

この例では：
- 文字列を受け取るバージョンと配列を受け取るバージョンの2つのシグネチャを定義しています
- 実際の実装では、両方のケースをカバーするユニオン型を使用しています

関数の型をきちんと指定することで、コードの意図が明確になり、誤った使い方を防ぐことができます。特に大規模なプロジェクトでは、型による制約がコードの品質向上に大きく貢献します。
