# 6. TypeScriptの高度な型

TypeScriptの大きな強みの一つは、豊富で柔軟な型システムです。基本的な型を超えて、より高度な型機能を利用することで、コードの安全性、可読性、保守性を高めることができます。

## ユニオン型とインターセクション型

### ユニオン型 (Union Types)

ユニオン型は、「または」の関係を表現する型で、複数の型のうちいずれかの型を持つことができます。`|`（パイプ）記号を使って表現します。

```typescript
// ユニオン型の基本
let id: string | number;  // idはstringまたはnumber型

id = 123;  // OK
id = "ABC";  // OK
// id = true;  // エラー: booleanは許可されていない

// 関数の引数や戻り値にも使用可能
function formatId(id: string | number): string {
  if (typeof id === "string") {
    return id.toUpperCase();  // idはstring型として扱われる
  } else {
    return `ID-${id.toString().padStart(6, "0")}`;  // idはnumber型として扱われる
  }
}

console.log(formatId("abc"));  // "ABC"
console.log(formatId(123));  // "ID-000123"
```

#### 判別可能なユニオン型 (Discriminated Unions)

共通のプロパティ（タグ）を持つオブジェクト型のユニオンは、タイプセーフな処理が可能になります。

```typescript
// 判別可能なユニオン型
type 円 = {
  種類: "円";  // リテラル型としてのタグ
  半径: number;
};

type 長方形 = {
  種類: "長方形";  // リテラル型としてのタグ
  幅: number;
  高さ: number;
};

type 図形 = 円 | 長方形;  // 判別可能なユニオン型

function 面積を計算(図: 図形): number {
  switch (図.種類) {
    case "円":
      return Math.PI * 図.半径 * 図.半径;  // 図は円型として扱われる
    case "長方形":
      return 図.幅 * 図.高さ;  // 図は長方形型として扱われる
  }
}

const 円1: 円 = { 種類: "円", 半径: 5 };
const 長方形1: 長方形 = { 種類: "長方形", 幅: 4, 高さ: 6 };

console.log(面積を計算(円1));  // 約78.54
console.log(面積を計算(長方形1));  // 24
```

### インターセクション型 (Intersection Types)

インターセクション型は、「かつ」の関係を表現する型で、複数の型のすべての機能を持つ型を作成します。`&`（アンパサンド）記号を使って表現します。

```typescript
// インターセクション型の基本
type 社員情報 = {
  id: number;
  名前: string;
};

type 技術情報 = {
  スキル: string[];
  経験年数: number;
};

// インターセクション型（両方の型のプロパティをすべて持つ）
type エンジニア = 社員情報 & 技術情報;

const 田中さん: エンジニア = {
  id: 1,
  名前: "田中太郎",
  スキル: ["TypeScript", "React", "Node.js"],
  経験年数: 5
};

// すべてのプロパティを持っていないとエラー
// const 山田さん: エンジニア = {
//   id: 2,
//   名前: "山田花子",
//   スキル: ["JavaScript"]  // エラー: '経験年数' プロパティがありません
// };
```

インターセクション型は、既存の型を組み合わせて新しい型を作成する際に非常に便利です。特に、複数のインターフェースを実装するクラスを表現する場合や、機能を追加する場合に役立ちます。

## ジェネリック型

ジェネリック型は、型の一部をパラメータ化して、再利用可能なコンポーネントを作成するための機能です。異なる型に対して同じロジックを適用したい場合に特に役立ちます。

### ジェネリック関数

```typescript
// ジェネリック関数の基本
function 最初の要素を取得<T>(配列: T[]): T | undefined {
  return 配列.length > 0 ? 配列[0] : undefined;
}

// 使用時に型が推論される
const 最初の数字 = 最初の要素を取得([1, 2, 3]);  // number型と推論される
const 最初の文字列 = 最初の要素を取得(["a", "b", "c"]);  // string型と推論される
const 最初のオブジェクト = 最初の要素を取得([{ id: 1, 名前: "田中" }]);  // { id: number, 名前: string }型と推論される

// 明示的に型を指定することも可能
const 最初の数字2 = 最初の要素を取得<number>([1, 2, 3]);
```

### ジェネリッククラス

```typescript
// ジェネリッククラスの例
class コレクション<T> {
  private アイテム: T[] = [];

  追加(アイテム: T): void {
    this.アイテム.push(アイテム);
  }

  取得(インデックス: number): T {
    return this.アイテム[インデックス];
  }

  全て取得(): T[] {
    return [...this.アイテム];
  }
}

// 数値のコレクション
const 数値コレクション = new コレクション<number>();
数値コレクション.追加(1);
数値コレクション.追加(2);
数値コレクション.追加(3);
console.log(数値コレクション.全て取得());  // [1, 2, 3]

// 文字列のコレクション
const 文字列コレクション = new コレクション<string>();
文字列コレクション.追加("a");
文字列コレクション.追加("b");
文字列コレクション.追加("c");
console.log(文字列コレクション.全て取得());  // ["a", "b", "c"]

// オブジェクトのコレクション
interface ユーザー {
  id: number;
  名前: string;
}

const ユーザーコレクション = new コレクション<ユーザー>();
ユーザーコレクション.追加({ id: 1, 名前: "田中" });
ユーザーコレクション.追加({ id: 2, 名前: "山田" });
console.log(ユーザーコレクション.全て取得());  // [{ id: 1, 名前: "田中" }, { id: 2, 名前: "山田" }]
```

### 型制約（Constraints）

ジェネリック型パラメータに制約を加えることで、特定のプロパティを持つ型に限定することができます。

```typescript
// 型制約の例
interface 名前付き {
  名前: string;
}

// T型は名前付きインターフェースを満たす必要がある
function 名前を表示<T extends 名前付き>(アイテム: T): void {
  console.log(`名前: ${アイテム.名前}`);
}

const 人 = { id: 1, 名前: "田中太郎", 年齢: 30 };
名前を表示(人);  // "名前: 田中太郎"

// 名前プロパティを持たないオブジェクトはエラー
// const 場所 = { 住所: "東京都" };
// 名前を表示(場所);  // エラー: '名前' プロパティがありません
```

## ユーティリティ型

TypeScriptには、既存の型から新しい型を作成するための組み込みユーティリティ型が多数あります。以下に代表的なものをいくつか紹介します。

### Partial\<T>

`Partial<T>`は、Tのすべてのプロパティをオプショナル（省略可能）にした型を作成します。

```typescript
// Partial<T>の例
interface ユーザー {
  id: number;
  名前: string;
  メール: string;
  年齢: number;
}

// ユーザー情報の一部だけを更新する関数
function ユーザーを更新(id: number, 更新情報: Partial<ユーザー>): void {
  // データベースからユーザーを取得して更新する処理（省略）
  console.log(`ID ${id} のユーザーを更新: `, 更新情報);
}

// 一部のプロパティだけを指定して更新
ユーザーを更新(1, { 名前: "新しい名前" });
ユーザーを更新(2, { メール: "new@example.com", 年齢: 31 });
```

### Readonly\<T>

`Readonly<T>`は、Tのすべてのプロパティを読み取り専用にした型を作成します。

```typescript
// Readonly<T>の例
interface ポイント {
  x: number;
  y: number;
}

const 点: Readonly<ポイント> = { x: 10, y: 20 };
console.log(点.x, 点.y);  // 10, 20
// 点.x = 30;  // エラー: 読み取り専用プロパティを変更しようとしています
```

### Pick\<T, K>

`Pick<T, K>`は、Tから指定されたプロパティKだけを含む型を作成します。

```typescript
// Pick<T, K>の例
interface ユーザー {
  id: number;
  名前: string;
  メール: string;
  住所: string;
  電話番号: string;
}

// idと名前だけを含む型
type ユーザー基本情報 = Pick<ユーザー, "id" | "名前">;

const 基本情報リスト: ユーザー基本情報[] = [
  { id: 1, 名前: "田中" },
  { id: 2, 名前: "山田" }
];

// メールと電話番号だけを含む型
type 連絡先情報 = Pick<ユーザー, "メール" | "電話番号">;

const 連絡先: 連絡先情報 = {
  メール: "tanaka@example.com",
  電話番号: "03-1234-5678"
};
```

### Omit\<T, K>

`Omit<T, K>`は、Tから指定されたプロパティKを除外した型を作成します。

```typescript
// Omit<T, K>の例
interface 商品 {
  id: number;
  名前: string;
  価格: number;
  在庫: number;
  説明: string;
}

// 内部管理用の情報（在庫を除く）
type 公開商品情報 = Omit<商品, "在庫">;

const 商品ページ表示: 公開商品情報 = {
  id: 1,
  名前: "TypeScriptの本",
  価格: 3000,
  説明: "TypeScriptの入門書です。"
  // 在庫は含まれない
};
```

### Record\<K, T>

`Record<K, T>`は、キーの型がKで値の型がTのオブジェクト型を作成します。

```typescript
// Record<K, T>の例
type 果物名 = "りんご" | "みかん" | "バナナ";
type 果物情報 = { 価格: number; 産地: string };

const 果物データ: Record<果物名, 果物情報> = {
  りんご: { 価格: 200, 産地: "青森" },
  みかん: { 価格: 150, 産地: "愛媛" },
  バナナ: { 価格: 100, 産地: "フィリピン" }
};

console.log(果物データ.りんご);  // { 価格: 200, 産地: "青森" }
```

これらのユーティリティ型を組み合わせることで、より複雑な型の操作も可能です。TypeScriptの型システムを活用することで、コードの安全性と表現力を大幅に向上させることができます。
