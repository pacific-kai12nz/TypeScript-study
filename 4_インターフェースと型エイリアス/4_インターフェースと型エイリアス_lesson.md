# 4. インターフェースと型エイリアス

TypeScriptでは、オブジェクトの形状を定義するための「インターフェース」と「型エイリアス」という2つの主要な方法があります。これらを使うことで、型を再利用し、コードの可読性と保守性を高めることができます。

## インターフェースの基本

インターフェースは、オブジェクトの構造（プロパティと型）を定義するためのもので、`interface`キーワードを使って宣言します。

### 基本的なインターフェース

```typescript
// ユーザー情報のインターフェース
interface ユーザー {
  id: number;
  名前: string;
  年齢: number;
  メールアドレス: string;
}

// インターフェースを使用した変数宣言
const ユーザー1: ユーザー = {
  id: 1,
  名前: "田中太郎",
  年齢: 30,
  メールアドレス: "tanaka@example.com"
};
```

### オプショナルプロパティ

インターフェースでも、オプショナルプロパティを定義できます。

```typescript
interface 社員 {
  社員番号: number;
  名前: string;
  部署?: string;  // オプショナルプロパティ
  役職?: string;  // オプショナルプロパティ
}

const 社員1: 社員 = {
  社員番号: 101,
  名前: "鈴木花子"
  // 部署と役職は省略可能
};

const 社員2: 社員 = {
  社員番号: 102,
  名前: "佐藤次郎",
  部署: "営業部",
  役職: "主任"
};
```

### 読み取り専用プロパティ

`readonly`修飾子を使うと、一度設定されたらその後変更できないプロパティを定義できます。

```typescript
interface 設定 {
  readonly API_KEY: string;
  readonly DEBUG_MODE: boolean;
  タイムアウト: number;  // 読み取り専用ではない
}

const アプリ設定: 設定 = {
  API_KEY: "abcd1234",
  DEBUG_MODE: true,
  タイムアウト: 3000
};

// OK - 読み取り専用ではないプロパティは変更可能
アプリ設定.タイムアウト = 5000;

// エラー - 読み取り専用プロパティは変更できない
// アプリ設定.API_KEY = "xyz9876";  // これはコンパイルエラーになります
```

### 関数を含むインターフェース

インターフェースでは、メソッド（オブジェクトに属する関数）も定義できます。

```typescript
interface 計算機 {
  値: number;
  加算(x: number): void;
  減算(x: number): void;
  現在値(): number;
}

// インターフェースを実装するオブジェクト
const 電卓: 計算機 = {
  値: 0,
  加算(x: number): void {
    this.値 += x;
  },
  減算(x: number): void {
    this.値 -= x;
  },
  現在値(): number {
    return this.値;
  }
};

// 使用例
電卓.加算(5);    // 値が5になる
電卓.加算(3);    // 値が8になる
電卓.減算(2);    // 値が6になる
console.log(電卓.現在値());  // 6
```

## 型エイリアスの基本

型エイリアスは、任意の型に名前をつけるためのもので、`type`キーワードを使って宣言します。

### 基本的な型エイリアス

```typescript
// プリミティブ型のエイリアス
type ID = number;
type 名前 = string;
type 真偽値 = boolean;

// 複合型のエイリアス
type 座標 = {
  x: number;
  y: number;
};

// 使用例
const ユーザーID: ID = 12345;
const 点A: 座標 = { x: 10, y: 20 };
```

### ユニオン型とリテラル型

型エイリアスは特に、ユニオン型やリテラル型と組み合わせると便利です。

```typescript
// ユニオン型（複数の型のいずれか）
type 数値または文字列 = number | string;

// リテラル型（特定の値のみを許可）
type 方向 = "上" | "下" | "左" | "右";

// 使用例
function 表示(値: 数値または文字列) {
  console.log(値);
}

表示(100);         // OK
表示("こんにちは");  // OK
// 表示(true);     // エラー: boolean型は許可されていない

function 移動(方向: 方向, 距離: number) {
  console.log(`${方向}に${距離}単位移動しました`);
}

移動("上", 5);     // OK
// 移動("斜め", 5);  // エラー: "斜め"は許可された方向ではない
```

### 型エイリアスと関数型

型エイリアスは関数の型にも名前を付けることができます。

```typescript
// 関数型のエイリアス
type 文字列変換関数 = (入力: string) => string;

// 使用例
const 大文字化: 文字列変換関数 = (入力: string) => 入力.toUpperCase();
const 小文字化: 文字列変換関数 = (入力: string) => 入力.toLowerCase();

console.log(大文字化("Hello"));  // "HELLO"
console.log(小文字化("Hello"));  // "hello"
```

## インターフェースと型エイリアスの違い

インターフェースと型エイリアスは似ていますが、いくつかの違いがあります。

### 拡張の方法

インターフェースは`extends`キーワードを使って拡張できます。

```typescript
// インターフェースの拡張
interface 動物 {
  名前: string;
  鳴く(): void;
}

interface イヌ extends 動物 {
  吠える(): void;
}

const 柴犬: イヌ = {
  名前: "ポチ",
  鳴く() {
    console.log("ワンワン");
  },
  吠える() {
    console.log("バウバウ");
  }
};
```

型エイリアスは交差型（`&`演算子）を使って拡張します。

```typescript
// 型エイリアスの拡張
type 動物 = {
  名前: string;
  鳴く(): void;
};

type イヌ = 動物 & {
  吠える(): void;
};

const 柴犬: イヌ = {
  名前: "ポチ",
  鳴く() {
    console.log("ワンワン");
  },
  吠える() {
    console.log("バウバウ");
  }
};
```

### 定義の宣言的マージ

インターフェースは同じ名前で複数回宣言すると、それらがマージされます。

```typescript
// インターフェースの宣言的マージ
interface 車 {
  メーカー: string;
  モデル: string;
}

interface 車 {
  年式: number;
  色: string;
}

// 両方のインターフェースがマージされる
const 自動車: 車 = {
  メーカー: "トヨタ",
  モデル: "プリウス",
  年式: 2020,
  色: "白"
};
```

型エイリアスは再宣言できません。

```typescript
// 型エイリアスの再宣言（エラー）
type 車 = {
  メーカー: string;
  モデル: string;
};

// エラー: 同じ名前の型エイリアスを重複定義できない
// type 車 = {
//   年式: number;
//   色: string;
// };
```

### 用途の選択

一般的なガイドラインとして：

- **インターフェース**は、オブジェクトの構造を定義する場合や、クラスが実装すべき契約を定義する場合に適しています。特に将来拡張される可能性がある場合はインターフェースを使うと便利です。

- **型エイリアス**は、ユニオン型、交差型、プリミティブ型、リテラル型などの複雑な型に名前をつける場合や、特定の型パターンを再利用する場合に適しています。

どちらを使うかは、プロジェクトの要件や好みによって異なりますが、一つのプロジェクト内では一貫性を保つことが重要です。
